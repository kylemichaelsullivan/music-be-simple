---
alwaysApply: true
---

# Music Be Simple Project Rules

Music Be Simple is a web application for learning and exploring music theory. It provides interactive visualizations of scales and chords across multiple instruments (Piano, Guitar, Banjo, Ukulele, Mandolin), allowing users to understand music theory concepts through visual representation and audio playback. The app features three main sections: Scales (for exploring musical scales and modes), Chords (for chord construction and visualization), and Play (for interactive instrument exploration).

## Core Principles

- Write and review code like a senior developer
- Challenge erroneous assumptions and inefficiencies
- Always use **bun** for package management and all package-related operations
- Use **TypeScript** with strict configuration
- Follow **React 19** with **Vite** architecture
- Use **TanStack Router** for routing
- Use **Zustand stores** and **React Context API** for state management (hybrid approach)
- Use typographic apostrophe ' instead of straight apostrophe ' in ALL user-facing text

## Package Management

- **Package Manager**: **bun** (always use bun for all package-related operations)
- **Build Command**: `bun run build` (TypeScript compilation + Vite build)
- **Development Command**: `bun dev` (Vite dev server with HMR)
- **Lock File**: `bun.lock`

## Development Scripts

### Available Commands

- **Development Server**: `bun dev` (Vite dev server with HMR)
- **Production Build**: `bun run build` (TypeScript compilation + Vite build)
- **Linting**: `bun lint` (Run Biome linter)
- **Formatting**: `bun format` (Format code with Biome)
- **Testing**: `bun test` (Run unit and component tests in watch mode)
- **Test UI**: `bun test:ui` (Run tests with Vitest UI)
- **Test Run**: `bun test:run` (Run tests once, CI mode)
- **Test Coverage**: `bun test:coverage` (Run tests with coverage report)
- **E2E Tests**: `bun test:e2e` (Run end-to-end tests with Playwright)
- **E2E UI**: `bun test:e2e:ui` (Run E2E tests with Playwright UI)
- **E2E Headed**: `bun test:e2e:headed` (Run E2E tests in headed mode)
- **All Tests**: `bun test:all` (Run both unit and E2E tests)

### Vite Benefits

- **Fast HMR**: Hot Module Replacement for instant updates
- **Optimized builds**: Production builds with code splitting
- **TypeScript support**: Native TypeScript support
- **Plugin ecosystem**: Rich plugin ecosystem (React, Tailwind, TanStack Router)

## Project Structure

```
src/
├── components/          # React components
│   ├── __tests__/       # Component tests
│   ├── buttons/         # Button components
│   │   ├── TopButton.tsx
│   │   ├── TransposeButton.tsx
│   │   └── UseFlatsButton.tsx
│   ├── displays/        # Display components
│   │   ├── Displays.tsx
│   │   ├── DisplaySelector.tsx
│   │   ├── DisplaysSelector.tsx
│   │   ├── Modes.tsx
│   │   └── instruments/ # Instrument display components
│   │       ├── Banjo.tsx
│   │       ├── Guitar.tsx
│   │       ├── Instrument.tsx
│   │       ├── Mandolin.tsx
│   │       ├── Piano.tsx
│   │       └── Ukulele.tsx
│   ├── nav/             # Navigation components
│   │   ├── Navbar.tsx
│   │   └── NavTab.tsx
│   ├── AllowedNote.tsx  # Note display component
│   ├── Footer.tsx       # Footer component
│   ├── Icon.tsx         # Icon component
│   ├── Main.tsx         # Main content wrapper component
│   ├── Title.tsx        # Title component
│   ├── Tonic.tsx        # Tonic selector component
│   └── Variant.tsx      # Variant selector component
├── context/             # React Context providers
│   ├── Chords/          # Chords context provider
│   │   ├── ChordsContext.tsx
│   │   └── index.tsx
│   ├── Globals/         # Global context provider
│   │   ├── GlobalsContext.tsx
│   │   └── index.tsx
│   ├── InstrumentNotes/ # Instrument notes context provider
│   │   ├── InstrumentNotesContext.tsx
│   │   └── index.tsx
│   ├── Play/            # Play context provider
│   │   ├── PlayContext.tsx
│   │   └── index.tsx
│   ├── Scales/          # Scales context provider
│   │   ├── ScalesContext.tsx
│   │   └── index.tsx
│   ├── shared/          # Shared context utilities
│   │   ├── index.ts
│   │   ├── useEscapeReset.ts
│   │   ├── useLocalStorage.ts
│   │   └── useRequireGlobals.ts
│   ├── defaults.tsx     # Default context values
│   └── index.ts         # Context exports
├── hooks/               # Custom React hooks
│   ├── __tests__/       # Hook tests
│   ├── useButtonHandler.ts
│   ├── useChords.ts
│   ├── useGlobals.ts
│   ├── useInstrumentNotes.ts
│   ├── usePlay.ts
│   ├── usePlayNote.ts
│   └── useScales.ts
├── pages/               # Page components
│   ├── Chords/
│   │   ├── index.tsx    # Chords page
│   │   ├── Chord.tsx
│   │   ├── ChordName.tsx
│   │   ├── ChordNote.tsx
│   │   ├── ChordNotes.tsx
│   │   └── Notes.tsx
│   ├── Play/
│   │   └── index.tsx    # Play page
│   └── Scales/
│       ├── index.tsx    # Scales page
│       ├── Notes.tsx
│       ├── Scale.tsx
│       └── ScaleContainer.tsx
├── routes/              # TanStack Router route definitions
│   ├── __root.tsx       # Root route layout
│   ├── index.tsx        # Home/index route (redirects to scales)
│   ├── chords.tsx       # Chords route with context provider
│   ├── play.tsx         # Play route with context provider
│   └── scales.tsx       # Scales route with context provider
├── stores/              # Zustand stores for state management
│   ├── chordsStore.ts   # Chords tonic/variant store
│   ├── scalesStore.ts   # Scales tonic/variant store
│   ├── playStore.ts     # Play functionality store
│   └── index.ts         # Store exports
├── types/               # TypeScript type definitions
│   ├── chords.ts
│   ├── globals.ts
│   ├── index.ts
│   ├── play.ts
│   └── scales.ts
├── utils/               # Utility functions
│   ├── __tests__/       # Unit tests for utility functions
│   ├── borders.ts
│   ├── chords.ts
│   ├── index.ts
│   ├── notes.ts
│   └── scales.ts
├── test/                # Test utilities and setup
│   ├── setup.ts         # Test setup and mocks
│   └── test-utils.tsx   # Testing utilities and helpers
├── main.tsx             # Application entry point
├── navigation.ts        # Navigation constants and schemas
├── instruments.ts       # Instrument definitions
├── globals.css          # Global styles and CSS variables
└── vite-env.d.ts        # Vite environment type definitions

e2e/                     # End-to-end tests
├── scales.spec.ts       # E2E tests for scales page
├── chords.spec.ts       # E2E tests for chords page
├── play.spec.ts         # E2E tests for play page
└── navigation.spec.ts   # E2E tests for navigation
```

## Code Organization

### Import Organization

- **Defined order**: Follow specific import order, then alphabetize within each group
- **Import order**:
  1. Type imports (alphabetically by path, including React types)
  2. React value imports (from 'react')
  3. Third-party libraries (alphabetically by source)
  4. Internal project imports (alphabetically by path)
- **Avoid React namespace**: Import React types directly, avoid `React.` prefix
- **Default imports**: Use default imports for components, named imports for hooks and utilities

#### Import Order Example

```tsx
// 1. Type imports (alphabetically by path)
import type { ReactNode } from 'react';
import type { TabType } from '@/types';

// 2. React value imports
import { useState } from 'react';

// 3. Third-party libraries (alphabetically by source)
import { Link } from '@tanstack/react-router';
import clsx from 'clsx';

// 4. Internal project imports (alphabetically by path)
import Main from '@/components/Main';
import { useScales } from '@/hooks/useScales';
```

### File Structure

```tsx
// Standard component file structure (default export pattern)
import type { ReactNode } from 'react';
import { useState } from 'react';

import Main from '@/components/Main';
import { useScales } from '@/hooks/useScales';

// Default export pattern (current working pattern)
export default function ComponentName() {
	const [localState, setLocalState] = useState('');
	const { tonic, variant, notes } = useScales();

	return (
		<Main componentName='ComponentName'>
			{/* Component content */}
		</Main>
	);
}

// Alternative: Component with props
type ComponentProps = {
	// Required props
	title: string;
	// Optional props with defaults
	variant?: 'primary' | 'secondary';
	size?: 'sm' | 'md' | 'lg';
	disabled?: boolean;
	// Children
	children?: ReactNode;
};

export default function ComponentName({
	title,
	variant = 'primary',
	children,
}: ComponentProps) {
	return (
		<div className='ComponentName'>
			{/* Component content */}
		</div>
	);
}
```

## Styling Guidelines

### CSS and Styling

- **Avoid Tailwind margin/space classes**: Do not use `space-x-*` or `space-y-*` utilities - use flex/gap instead
- **Use flex/gap spacing**: Use `flex flex-col gap-*` for vertical spacing and `flex items-center gap-*` for horizontal spacing
- **No !important declarations**: Avoid using `!important` in CSS
- **CSS variables**: Use CSS variables for colors and fonts (defined in globals.css)
- **Tailwind utilities**: Use Tailwind utility classes for styling
- **Custom CSS**: Use custom CSS classes for complex or reusable patterns (accordion, metronome, etc.)

### Spacing Examples

```tsx
// ❌ Avoid - margin-based spacing
<div className='space-y-4'>
  <Component />
</div>

// ✅ Good - flexbox-based spacing
<div className='flex flex-col gap-4'>
  <Component />
</div>
```

### React Best Practices

- **TypeScript**: Avoid using `any` type, prefer proper typing
- **Type assertions**: Avoid type assertions (`as Type`) except for `as const`. Use type guards and proper type narrowing instead
- **Default exports**: Use default exports for components (e.g., `export default function ComponentName`)
- **Path aliases**: Use `@/` alias for imports (configured in tsconfig.json)
- **State management**: Use React Context API with custom hooks for global state, `useState` for local component state
- **Router integration**: Components should work seamlessly with TanStack Router

#### Type Assertion Guidelines

```tsx
// ❌ Avoid - type assertions
const value = someValue as NoteIndex;
const mode = someMode as ScaleMode;

// ✅ Good - use type guards
function isValidNoteIndex(value: number): value is NoteIndex {
	return value >= 0 && value <= 11 && Number.isInteger(value);
}

if (isValidNoteIndex(value)) {
	// value is now properly typed as NoteIndex
	handleNoteChange(value);
}

// ✅ Allowed - as const for literal types
export const FLATS = ['C', 'D♭', 'D'] as const;
```

## Data Management

### State Management

The project uses a **hybrid approach** combining **Zustand stores** and **React Context API**:

- **Zustand stores**: Manage tonic and variant state for scales and chords (in `src/stores/`)
- **Context providers**: Provide computed values, UI state, and additional functionality (in `src/context/`)
- **Provider location**: Context providers are in `src/context/` directory, stores in `src/stores/`
- **Provider usage**: Context providers wrap page components at the route level
- **Custom hooks**: Use custom hooks (`useChords`, `useScales`, `usePlay`, `useGlobals`) to access context values
- **Store hooks**: Use store hooks (`useChordsStore`, `useScalesStore`, `usePlayStore`) to access store state
- **Persistence**: 
  - **sessionStorage** (via Zustand): Tonic and variant state (persists during navigation, clears on refresh)
  - **localStorage** (via `useLocalStorage`): UI preferences (persists across refreshes)
- **Type safety**: All context values and store state are typed with TypeScript
- **Schema validation**: Zod schemas validate data at runtime for both sessionStorage and localStorage

### Schema Validation with Zod

The project uses **Zod** for runtime type validation and schema definition:

- **Schema location**: All schemas are defined in `src/schemas.ts`
- **Validation**: Zod schemas validate data at runtime, ensuring type safety beyond TypeScript compile-time checks
- **sessionStorage validation**: All sessionStorage data (in Zustand stores) is validated using Zod schemas in custom storage implementations
- **localStorage validation**: All localStorage data is validated using Zod schemas via `useLocalStorage` hook
- **Input validation**: User inputs (e.g., form selections) are validated using Zod schemas with `safeParse()`
- **Schema types**: Schemas include basic types (NoteIndex, AccidentalType), enums (ScaleType, ChordVariant, InstrumentType), and complex objects (storage schemas)

#### Schema Usage Patterns

```tsx
// ✅ Use schemas for localStorage validation (for persisted fields)
import { useLocalStorage } from '@/context/shared/useLocalStorage';
import { IconTypeSchema } from '@/schemas';
import { z } from 'zod';

const [usingFlats, setUsingFlats] = useLocalStorage('usingFlats', z.boolean(), true);
const [displays, setDisplays] = useLocalStorage(
  'selectedDisplays',
  z.array(IconTypeSchema),
  initialDisplays
);

// ✅ Use safeParse for user input validation
import { NoteIndexSchema } from '@/schemas';

const handleChange = (e: ChangeEvent<HTMLSelectElement>) => {
  const value = Number.parseInt(e.target.value, 10);
  const result = NoteIndexSchema.safeParse(value);
  if (result.success && isValidNoteIndex(result.data)) {
    handleTonicChange(result.data);
  }
};
```

#### Available Schemas

- **Basic schemas**: `NoteIndexSchema`, `AccidentalTypeSchema`, `ScaleTypeSchema`, `ScaleModeSchema`, `ChordVariantSchema`
- **UI schemas**: `BorderSchema`, `InstrumentTypeSchema`, `IconTypeSchema`, `TabTypeSchema`, `PositionTypeSchema`
- **Button schemas**: `NerdModeButtonIconSchema`, `NoteLabelsButtonIconSchema`
- **Storage schemas**: `GlobalsStorageSchema`, `ScalesStorageSchema`, `ChordsStorageSchema` (used for combined data validation in context providers via `useEffect` hooks)
- **Data schemas**: `ChordInfoSchema`, `ChordDataSchema`, `ChordGroupSchema`

**Note**: Storage schemas are used for combined data validation in context providers (for monitoring and debugging), while individual localStorage fields are validated individually via `useLocalStorage` hook (e.g., `z.boolean()` for `usingFlats`, `z.array(IconTypeSchema)` for `selectedDisplays`).

### Store Structure

- **chordsStore**: Chords tonic and variant state (sessionStorage)
- **scalesStore**: Scales tonic and variant state (sessionStorage)
- **playStore**: Play functionality state (sessionStorage)

### Context Structure

- **GlobalsContext**: Global application state (note display preferences, selected displays, etc.) - uses localStorage
- **ScalesContext**: Scales-specific state (uses scalesStore for tonic/variant, computed notes, display options) - showNoteLabels in localStorage
- **ChordsContext**: Chords-specific state (uses chordsStore for tonic/variant, computed notes, chord info) - showNerdMode in localStorage
- **PlayContext**: Play functionality state (audio context, note playing)

### State Usage

```tsx
// ✅ Use context hooks
import { useScales } from '@/hooks/useScales';
import { useGlobals } from '@/hooks/useGlobals';

function Component() {
	const { tonic, variant, notes, handleTonicChange } = useScales();
	const { displays, usingFlats } = useGlobals();
	
	// Use state
	return <div>{notes.map(note => /* render */)}</div>;
}
```

### Context Provider Pattern

```tsx
// Route file wraps page with context provider
import { ScalesContextProvider } from '@/context';
import Scales from '@/pages/Scales';

function ScalesPage() {
	return (
		<ScalesContextProvider>
			<Scales />
		</ScalesContextProvider>
	);
}
```

## Routing

### TanStack Router

- **File-based routing**: Routes are defined in `src/routes/` directory
- **Route generation**: Route tree is auto-generated via TanStack Router plugin
- **Route structure**: Each route file exports a route definition
- **Root route**: `__root.tsx` defines the root layout with Navbar and Outlet
- **Navigation**: Use `Link` component from `@tanstack/react-router` for navigation

### Routing Usage

```tsx
// ✅ Use TanStack Router Link
import { Link } from '@tanstack/react-router';

<Link
	to='/chords'
	className='...'
	activeProps={{ className: '...' }}
>
	Chords
</Link>
```

## Testing

The project uses a comprehensive testing setup:

- **Unit Tests**: Vitest + React Testing Library for utility functions and hooks
- **Component Tests**: Vitest + React Testing Library for React components
- **E2E Tests**: Playwright for end-to-end user flow testing
- **Coverage**: Vitest Coverage (v8) for code coverage reports

### Test Structure

- Unit tests: `src/utils/__tests__/`, `src/hooks/__tests__/`
- Component tests: `src/components/__tests__/`
- E2E tests: `e2e/`
- Test utilities: `src/test/test-utils.tsx` (custom render with router context)
- Test setup: `src/test/setup.ts` (mocks and global configuration)

### Testing Best Practices

- **Test behavior, not implementation**: Focus on what users see and do
- **Use semantic queries**: Prefer `getByRole`, `getByLabelText` over `getByTestId`
- **Keep tests isolated**: Each test should be independent
- **Write descriptive test names**: Use clear descriptions of what is being tested
- **Test user interactions**: Use `@testing-library/user-event` for interactions
- **Mock external dependencies**: Mock APIs, localStorage, etc.
- **Keep E2E tests focused**: Test critical user flows, not every detail

### Test Utilities

- Use `render` from `@/test/test-utils` for components that need router context
- Test setup includes mocks for `matchMedia`, `IntersectionObserver`, and `AudioContext`
- Coverage reports are generated in the `coverage/` directory

## Comments and Documentation

### Comment Guidelines

- **Minimal comments**: Limit comments to non-obvious functionality
- **Purpose comments**: Comment on oddities that have non-obvious purposes
- **Self-documenting code**: Write code that explains itself through clear naming and structure
- **JSDoc**: Use JSDoc comments for complex props and functions

## Communication Standards

### Progress Updates

- **Meaningful updates only**: Avoid inane progress updates and status reports
- **Focus on substance**: Communicate actual progress, blockers, or decisions that matter
- **No busy work updates**: Don't report on routine tasks or obvious progress
- **Context matters**: Provide context when updates are necessary
- **Efficiency**: Respect time by being concise and relevant

### Documentation Standards

- **Documentation directory**: Place all MD documentation in appropriate directories
- **Usage examples**: Provide clear usage examples
- **Props documentation**: Document all props with types and descriptions
- **Data structure documentation**: Document data file structure and usage

### Documentation Updates

- **Substantive changes only**: Update documentation for meaningful changes
- **Avoid trivial updates**: Don't update docs for minor formatting or obvious changes
- **Focus on value**: Document decisions, patterns, and changes that provide value
- **Clear purpose**: Ensure documentation updates serve a clear purpose
