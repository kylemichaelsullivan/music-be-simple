---
alwaysApply: true
---

# Music Be Simple Project Rules

Music Be Simple is a web application for learning and exploring music theory. It provides interactive visualizations of scales and chords across multiple instruments (Piano, Guitar, Banjo, Ukulele, Mandolin), allowing users to understand music theory concepts through visual representation and audio playback. The app features three main sections: Scales (for exploring musical scales and modes), Chords (for chord construction and visualization), and Play (for interactive instrument exploration).

## Core Principles

- Write and review code like a senior developer
- Challenge erroneous assumptions and inefficiencies
- Always use **bun** for package management and all package-related operations
- Use **TypeScript** with strict configuration
- Follow **React 19** with **Vite** architecture
- Use **TanStack Router** for routing
- Use **Zustand stores** and **React Context API** for state management (hybrid approach)
- Use typographic apostrophe ' instead of straight apostrophe ' in ALL user-facing text

## Package Management

- **Package Manager**: **bun** (always use bun for all package-related operations)
- **Build Command**: `bun run build` (TypeScript compilation + Vite build)
- **Development Command**: `bun dev` (Vite dev server with HMR)
- **Lock File**: `bun.lock`

## Development Scripts

### Available Commands

- **Development Server**: `bun dev` (Vite dev server with HMR)
- **Production Build**: `bun run build` (TypeScript compilation + Vite build)
- **Linting**: `bun lint` (Run Biome linter)
- **Formatting**: `bun format` (Format code with Biome)
- **Testing**: 
  - **Recommended**: `bun run test` (Run once, CI mode) or `bun run test:watch` (Watch mode) - Runs Vitest via npm script
    - Automatically excludes E2E tests (configured in vitest.config.ts)
    - Full Vitest API support
    - Most reliable for all tests
  - **Note**: Do NOT use `bun test` (Bun's built-in test runner) - It is not supported due to compatibility issues with Testing Library
- **Test Watch**: `bun run test:watch` (Run tests in watch mode, development)
- **Test UI**: `bun run test:ui` (Run tests with Vitest UI)
- **Test Coverage**: `bun run test:coverage` (Run tests with coverage report)
- **E2E Tests**: `bun run test:e2e` (Run end-to-end tests with Playwright)
- **E2E UI**: `bun run test:e2e:ui` (Run E2E tests with Playwright UI)
- **E2E Headed**: `bun run test:e2e:headed` (Run E2E tests in headed mode)
- **All Tests**: `bun run test:all` (Run both unit and E2E tests)

### Vite Benefits

- **Fast HMR**: Hot Module Replacement for instant updates
- **Optimized builds**: Production builds with code splitting
- **TypeScript support**: Native TypeScript support
- **Plugin ecosystem**: Rich plugin ecosystem (React, Tailwind, TanStack Router)

## Project Structure

```
src/
├── components/          # React components
│   ├── __tests__/       # Component tests
│   ├── buttons/         # Button components
│   │   ├── TopButton.tsx
│   │   ├── TransposeButton.tsx
│   │   └── UseFlatsButton.tsx
│   ├── displays/        # Display components
│   │   ├── Displays.tsx
│   │   ├── DisplaySelector.tsx
│   │   ├── DisplaysSelector.tsx
│   │   ├── Modes.tsx
│   │   └── instruments/ # Instrument display components
│   │       ├── Banjo.tsx
│   │       ├── Guitar.tsx
│   │       ├── Instrument.tsx
│   │       ├── Mandolin.tsx
│   │       ├── Piano.tsx
│   │       └── Ukulele.tsx
│   ├── nav/             # Navigation components
│   │   ├── Navbar.tsx
│   │   └── NavTab.tsx
│   ├── AllowedNote.tsx  # Note display component
│   ├── Footer.tsx       # Footer component
│   ├── Icon.tsx         # Icon component
│   ├── Main.tsx         # Main content wrapper component
│   ├── Title.tsx        # Title component
│   ├── Tonic.tsx        # Tonic selector component
│   └── Variant.tsx      # Variant selector component
├── context/             # React Context providers
│   ├── Chords/          # Chords context provider
│   │   ├── ChordsContext.tsx
│   │   └── index.tsx
│   ├── Globals/         # Global context provider
│   │   ├── GlobalsContext.tsx
│   │   └── index.tsx
│   ├── InstrumentNotes/ # Instrument notes context provider
│   │   ├── InstrumentNotesContext.tsx
│   │   └── index.tsx
│   ├── Play/            # Play context provider
│   │   ├── PlayContext.tsx
│   │   └── index.tsx
│   ├── Scales/          # Scales context provider
│   │   ├── ScalesContext.tsx
│   │   └── index.tsx
│   ├── shared/          # Shared context utilities
│   │   ├── index.ts
│   │   ├── useEscapeReset.ts
│   │   ├── useLocalStorage.ts
│   │   └── useRequireGlobals.ts
│   ├── defaults.tsx     # Default context values
│   └── index.ts         # Context exports
├── hooks/               # Custom React hooks
│   ├── __tests__/       # Hook tests
│   ├── useButtonHandler.ts
│   ├── useChords.ts
│   ├── useGlobals.ts
│   ├── useInstrumentNotes.ts
│   ├── usePlay.ts
│   ├── usePlayNote.ts
│   └── useScales.ts
├── pages/               # Page components
│   ├── Chords/
│   │   ├── index.tsx    # Chords page
│   │   ├── Chord.tsx
│   │   ├── ChordName.tsx
│   │   ├── ChordNote.tsx
│   │   ├── ChordNotes.tsx
│   │   └── Notes.tsx
│   ├── Play/
│   │   └── index.tsx    # Play page
│   └── Scales/
│       ├── index.tsx    # Scales page
│       ├── Notes.tsx
│       ├── Scale.tsx
│       └── ScaleContainer.tsx
├── routes/              # TanStack Router route definitions
│   ├── __root.tsx       # Root route layout
│   ├── index.tsx        # Home/index route (redirects to scales)
│   ├── chords.tsx       # Chords route with context provider
│   ├── play.tsx         # Play route with context provider
│   └── scales.tsx       # Scales route with context provider
├── stores/              # Zustand stores for state management
│   ├── chordsStore.ts   # Chords tonic/variant store
│   ├── scalesStore.ts   # Scales tonic/variant store
│   ├── playStore.ts     # Play functionality store
│   └── index.ts         # Store exports
├── types/               # TypeScript type definitions
│   ├── chords.ts
│   ├── globals.ts
│   ├── index.ts
│   ├── play.ts
│   └── scales.ts
├── utils/               # Utility functions
│   ├── __tests__/       # Unit tests for utility functions
│   ├── borders.ts
│   ├── chords.ts
│   ├── index.ts
│   ├── notes.ts
│   └── scales.ts
├── test/                # Test utilities and setup
│   ├── setup.ts         # Test setup and mocks
│   └── test-utils.tsx   # Testing utilities and helpers
├── main.tsx             # Application entry point
├── navigation.ts        # Navigation constants and schemas
├── instruments.ts       # Instrument definitions
├── globals.css          # Global styles and CSS variables
└── vite-env.d.ts        # Vite environment type definitions

e2e/                     # End-to-end tests
├── scales.spec.ts       # E2E tests for scales page
├── chords.spec.ts       # E2E tests for chords page
├── play.spec.ts         # E2E tests for play page
└── navigation.spec.ts   # E2E tests for navigation
```

## Code Organization

### Import Organization

- **All imports at top**: All imports must be at the top of the file without extra line breaks for automatic sorting
- **Import path rules**:
  1. Use relative imports (`./` or `../`) for:
     - Sibling files in the same directory
     - Direct child directories (one level down)
     - Direct parent directories (one level up, but NOT root level)
  2. Use `@/` alias for all other imports (cross-directory, root level, etc.)
- **Defined order**: Follow specific import order, then alphabetize within each group
- **Import order**:
  1. Internal project imports with `@/` alias (alphabetically by path: components, context, hooks, instruments, navigation, schemas, stores, utils)
  2. Type imports from `@/types` and other `@/` paths (alphabetically)
  3. React value imports (from 'react')
  4. Third-party libraries (alphabetically by source: clsx, zod, @tanstack/react-router, etc.)
  5. Relative imports (siblings, direct children, direct parents)
  6. Type imports from React (import type from 'react') - comes last
- **Separate code and type imports**: If importing both code and types from the same file, use separate import statements
- **Avoid React namespace**: Import React types directly, avoid `React.` prefix
- **Named imports only**: Use named imports/exports exclusively (no default exports)

#### Import Path Examples

```tsx
// ✅ Correct - Relative import for sibling
import { IconButton } from './IconButton';

// ✅ Correct - Relative import for direct child
import { Key } from './Key';

// ✅ Correct - Relative import for direct parent
import { Fret } from '../Fret';

// ✅ Correct - @/ alias for cross-directory
import { Main } from '@/components/Main';
import { useScales } from '@/hooks';

// ❌ Incorrect - @/ alias for sibling (should be relative)
import { IconButton } from '@/components/buttons/IconButton';

// ❌ Incorrect - Relative import for root level (should use @/)
import { TABS } from '../../navigation';
```

#### Import Order Example

```tsx
// All imports at top, no blank lines between groups
import { Main } from '@/components/Main';
import { useScales } from '@/hooks';
import type { TabType } from '@/types';
import { useState } from 'react';
import clsx from 'clsx';
import { Link } from '@tanstack/react-router';
import { IconButton } from './IconButton';
import type { ReactNode } from 'react';
```

#### Separate Code and Type Imports

If importing both code and types from the same file, use separate import statements:

```tsx
// ✅ Correct - Separate imports
import { render } from '@testing-library/react';
import type { RenderOptions } from '@testing-library/react';

// ❌ Incorrect - Combined import
import { type RenderOptions, render } from '@testing-library/react';
```

### Index Files (index.ts)

**Standardized Pattern**: All `index.ts` files MUST use direct export statements (no import-then-export pattern).

**Pattern**:
```ts
// ✅ Correct - Direct export pattern
export { ComponentA } from './ComponentA';
export { ComponentB } from './ComponentB';
export { NamedExport } from './NamedExport';
```

**For multiple exports from same file**:
```ts
// ✅ Correct - Multiple exports from same file
export { Button, Icon, Label } from './Button';
```

**For exports with aliases**:
```ts
// ✅ Correct - Export with alias
export { ScalesIndex as Scales } from './Scales';
```

**Formatting**:
- One export per line for clarity
- Alphabetize exports
- Add comments to organize related exports (optional, use sparingly)

**Examples**:
```ts
// Single component directory
export { Displays } from './Displays';
export { DisplaySelector } from './DisplaySelector';
export { DisplaysSelector } from './DisplaysSelector';
```

```ts
// Multiple exports with comments
// Defaults
export { initialTonic, initialVariant, initialUsingFlats } from './defaults';

// Shared
export { useChordState } from './shared/useChordState';
export { useScaleState } from './shared/useScaleState';
```

**When to create index.ts files**:
- Create `index.ts` files in directories that contain multiple related files
- Use `index.ts` for directories with exports that should be consumed from outside
- Each folder should have an `index.ts` that does direct exports
- Do NOT create `index.ts` if a directory already has `index.tsx` (page components)
- Do NOT create `index.ts` in test directories (`__tests__`, `__test__`)

**Important Notes**:
- Use direct exports: `export { X } from './X'` (NOT import-then-export)
- Keep index files simple - they are re-export files, not implementation files
- Alphabetize exports for maintainability
- Use consistent formatting across all index files

### File Structure

```tsx
// Standard component file structure (named export pattern)
import type { ReactNode } from 'react';
import { useState } from 'react';

import { Main } from '@/components/Main';
import { useScales } from '@/hooks/useScales';

// Named export pattern (required)
export function ComponentName() {
	const [localState, setLocalState] = useState('');
	const { tonic, variant, notes } = useScales();

	return (
		<Main componentName='ComponentName'>
			{/* Component content */}
		</Main>
	);
}

// Alternative: Component with props
type ComponentProps = {
	// Required props
	title: string;
	// Optional props with defaults
	variant?: 'primary' | 'secondary';
	size?: 'sm' | 'md' | 'lg';
	disabled?: boolean;
	// Children
	children?: ReactNode;
};

export function ComponentName({
	title,
	variant = 'primary',
	children,
}: ComponentProps) {
	return (
		<div className='ComponentName'>
			{/* Component content */}
		</div>
	);
}
```

## Styling Guidelines

### CSS and Styling

- **Avoid Tailwind margin/space classes**: Do not use `space-x-*` or `space-y-*` utilities - use flex/gap instead
- **Use flex/gap spacing**: Use `flex flex-col gap-*` for vertical spacing and `flex items-center gap-*` for horizontal spacing
- **No !important declarations**: Avoid using `!important` in CSS
- **CSS variables**: Use CSS variables for colors and fonts (defined in globals.css)
- **Tailwind utilities**: Use Tailwind utility classes for styling
- **Custom CSS**: Use custom CSS classes for complex or reusable patterns (accordion, metronome, etc.)

### Spacing Examples

```tsx
// ❌ Avoid - margin-based spacing
<div className='space-y-4'>
  <Component />
</div>

// ✅ Good - flexbox-based spacing
<div className='flex flex-col gap-4'>
  <Component />
</div>
```

### React Best Practices

- **TypeScript**: Avoid using `any` type, prefer proper typing
- **Type assertions**: Avoid type assertions (`as Type`) except for `as const`. Use type guards and proper type narrowing instead
- **Named exports only**: Use named exports for components (e.g., `export function ComponentName`) - NO default exports
- **Path aliases**: Use `@/` alias for imports (configured in tsconfig.json)
- **State management**: Use React Context API with custom hooks for global state, `useState` for local component state
- **Router integration**: Components should work seamlessly with TanStack Router

#### Type Assertion Guidelines

```tsx
// ❌ Avoid - type assertions
const value = someValue as NoteIndex;
const mode = someMode as ScaleMode;

// ✅ Good - use type guards
function isValidNoteIndex(value: number): value is NoteIndex {
	return value >= 0 && value <= 11 && Number.isInteger(value);
}

if (isValidNoteIndex(value)) {
	// value is now properly typed as NoteIndex
	handleNoteChange(value);
}

// ✅ Allowed - as const for literal types
export const FLATS = ['C', 'D♭', 'D'] as const;
```

## Data Management

### State Management

The project uses a **hybrid approach** combining **Zustand stores** and **React Context API**:

- **Zustand stores**: Manage tonic and variant state for scales and chords (in `src/stores/`)
- **Context providers**: Provide computed values, UI state, and additional functionality (in `src/context/`)
- **Provider location**: Context providers are in `src/context/` directory, stores in `src/stores/`
- **Provider usage**: Context providers wrap page components at the route level
- **Custom hooks**: Use custom hooks (`useChords`, `useScales`, `usePlay`, `useGlobals`) to access context values
- **Store hooks**: Use store hooks (`useChordsStore`, `useScalesStore`, `usePlayStore`) to access store state
- **Persistence**: 
  - **sessionStorage** (via Zustand): Tonic and variant state (persists during navigation, clears on refresh)
  - **localStorage** (via `useLocalStorage`): UI preferences (persists across refreshes)
- **Type safety**: All context values and store state are typed with TypeScript
- **Schema validation**: Zod schemas validate data at runtime for both sessionStorage and localStorage

### Schema Validation with Zod

The project uses **Zod** for runtime type validation and schema definition:

- **Schema location**: All schemas are defined in `src/schemas.ts`
- **Validation**: Zod schemas validate data at runtime, ensuring type safety beyond TypeScript compile-time checks
- **sessionStorage validation**: All sessionStorage data (in Zustand stores) is validated using Zod schemas in custom storage implementations
- **localStorage validation**: All localStorage data is validated using Zod schemas via `useLocalStorage` hook
- **Input validation**: User inputs (e.g., form selections) are validated using Zod schemas with `safeParse()`
- **Schema types**: Schemas include basic types (NoteIndex, AccidentalType), enums (ScaleType, ChordVariant, InstrumentType), and complex objects (storage schemas)

#### Schema Usage Patterns

```tsx
// ✅ Use schemas for localStorage validation (for persisted fields)
import { useLocalStorage } from '@/context/shared/useLocalStorage';
import { IconTypeSchema } from '@/schemas';
import { z } from 'zod';

const [usingFlats, setUsingFlats] = useLocalStorage('usingFlats', z.boolean(), true);
const [displays, setDisplays] = useLocalStorage(
  'selectedDisplays',
  z.array(IconTypeSchema),
  initialDisplays
);

// ✅ Use safeParse + type guard for user input validation
import { NoteIndexSchema, ScaleTypeSchema, ChordVariantSchema } from '@/schemas';
import { isValidNoteIndex, isValidScaleType, isValidChordVariant } from '@/utils';

// Pattern: Validate with Zod, then narrow type with type guard
const handleTonicChange = (e: ChangeEvent<HTMLSelectElement>) => {
  const value = Number.parseInt(e.target.value, 10);
  const result = NoteIndexSchema.safeParse(value);
  if (result.success && isValidNoteIndex(result.data)) {
    handleTonicChange(result.data); // Properly typed as NoteIndex
  }
};

const handleScaleVariantChange = (e: ChangeEvent<HTMLSelectElement>) => {
  const result = ScaleTypeSchema.safeParse(e.target.value);
  if (result.success && isValidScaleType(result.data)) {
    handleVariantChange(result.data); // Properly typed as ScaleType
  }
};

const handleChordVariantChange = (e: ChangeEvent<HTMLSelectElement>) => {
  const result = ChordVariantSchema.safeParse(e.target.value);
  if (result.success && isValidChordVariant(result.data)) {
    handleVariantChange(result.data); // Properly typed as Chord_Variant
  }
};
```

#### Available Schemas

- **Basic schemas**: `NoteIndexSchema`, `AccidentalTypeSchema`, `ScaleTypeSchema`, `ScaleModeSchema`, `ChordVariantSchema`
- **UI schemas**: `BorderSchema`, `InstrumentTypeSchema`, `IconTypeSchema`, `TabTypeSchema`, `PositionTypeSchema`
- **Button schemas**: `NerdModeButtonIconSchema`, `NoteLabelsButtonIconSchema`
- **Storage schemas**: `GlobalsStorageSchema`, `ScalesStorageSchema`, `ChordsStorageSchema` (used for combined data validation in context providers via `useEffect` hooks)
- **Data schemas**: `ChordInfoSchema`, `ChordDataSchema`, `ChordGroupSchema`

**Note**: Storage schemas are used for combined data validation in context providers (for monitoring and debugging), while individual localStorage fields are validated individually via `useLocalStorage` hook (e.g., `z.boolean()` for `usingFlats`, `z.array(IconTypeSchema)` for `selectedDisplays`).

### Store Structure

- **chordsStore**: Chords tonic and variant state (sessionStorage)
- **scalesStore**: Scales tonic and variant state (sessionStorage)
- **playStore**: Play functionality state (sessionStorage)

### Context Structure

- **GlobalsContext**: Global application state (note display preferences, selected displays, etc.) - uses localStorage
- **ScalesContext**: Scales-specific state (uses scalesStore for tonic/variant, computed notes, display options) - showNoteLabels in localStorage
- **ChordsContext**: Chords-specific state (uses chordsStore for tonic/variant, computed notes, chord info) - showNerdMode in localStorage
- **PlayContext**: Play functionality state (audio context, note playing)

### State Usage

```tsx
// ✅ Use context hooks
import { useScales } from '@/hooks/useScales';
import { useGlobals } from '@/hooks/useGlobals';

function Component() {
	const { tonic, variant, notes, handleTonicChange } = useScales();
	const { displays, usingFlats } = useGlobals();
	
	// Use state
	return <div>{notes.map(note => /* render */)}</div>;
}
```

### Context Provider Pattern

```tsx
// Route file wraps page with context provider
import { ScalesContextProvider } from '@/context';
import { Scales } from '@/pages/Scales';

function ScalesPage() {
	return (
		<ScalesContextProvider>
			<Scales />
		</ScalesContextProvider>
	);
}
```

## Routing

### TanStack Router

- **File-based routing**: Routes are defined in `src/routes/` directory
- **Route generation**: Route tree is auto-generated via TanStack Router plugin
- **Route structure**: Each route file exports a route definition
- **Root route**: `__root.tsx` defines the root layout with Navbar and Outlet
- **Navigation**: Use `Link` component from `@tanstack/react-router` for navigation

### Routing Usage

```tsx
// ✅ Use TanStack Router Link
import { Link } from '@tanstack/react-router';

<Link
	to='/chords'
	className='...'
	activeProps={{ className: '...' }}
>
	Chords
</Link>
```

## Testing

The project uses a comprehensive testing setup:

- **Unit Tests**: Vitest + React Testing Library for utility functions and hooks
- **Component Tests**: Vitest + React Testing Library for React components
- **E2E Tests**: Playwright for end-to-end user flow testing
- **Coverage**: Vitest Coverage (v8) for code coverage reports

### Test Structure

- Unit tests: `src/utils/__tests__/`, `src/hooks/__tests__/`
- Component tests: `src/components/__tests__/`
- E2E tests: `e2e/`
- Test utilities: `src/test/test-utils.tsx` (custom render with router context)
- Test setup: `src/test/setup.ts` (mocks and global configuration)

### Testing Best Practices

- **Test behavior, not implementation**: Focus on what users see and do
- **Use semantic queries**: Prefer `getByRole`, `getByLabelText` over `getByTestId`
- **Keep tests isolated**: Each test should be independent
- **Write descriptive test names**: Use clear descriptions of what is being tested
- **Test user interactions**: Use `@testing-library/user-event` for interactions
- **Mock external dependencies**: Mock APIs, localStorage, etc.
- **Keep E2E tests focused**: Test critical user flows, not every detail

### Test Utilities

- Use `render` from `@/test/test-utils` for components that need router context
- Test setup includes mocks for `matchMedia`, `IntersectionObserver`, and `AudioContext`
- Coverage reports are generated in the `coverage/` directory

### Running Tests

- **Use: `bun run test` (run once, CI mode) or `bun run test:watch` (watch mode)** - These commands run Vitest via npm scripts
  - Automatically excludes E2E tests (configured in vitest.config.ts)
  - Full Vitest API support
  - Most reliable for all tests
- **Note**: Do NOT use `bun test` (Bun's built-in test runner) - It is not supported due to compatibility issues with Testing Library's `screen` object and DOM environment setup
- Test setup files:
  - Vitest setup: `src/test/setup.ts` (loaded via vitest.config.ts)

## Comments and Documentation

### Comment Guidelines

- **Minimal comments**: Limit comments to non-obvious functionality
- **Purpose comments**: Comment on oddities that have non-obvious purposes
- **Self-documenting code**: Write code that explains itself through clear naming and structure
- **JSDoc**: Use JSDoc comments for complex props and functions

## Communication Standards

### Progress Updates

- **Meaningful updates only**: Avoid inane progress updates and status reports
- **Focus on substance**: Communicate actual progress, blockers, or decisions that matter
- **No busy work updates**: Don't report on routine tasks or obvious progress
- **Context matters**: Provide context when updates are necessary
- **Efficiency**: Respect time by being concise and relevant

### Documentation Standards

- **Documentation directory**: Place all MD documentation in appropriate directories
- **Usage examples**: Provide clear usage examples
- **Props documentation**: Document all props with types and descriptions
- **Data structure documentation**: Document data file structure and usage

### Documentation Updates

- **Substantive changes only**: Update documentation for meaningful changes
- **Avoid trivial updates**: Don't update docs for minor formatting or obvious changes
- **Focus on value**: Document decisions, patterns, and changes that provide value
- **Clear purpose**: Ensure documentation updates serve a clear purpose
