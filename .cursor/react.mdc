---
globs: **/*.tsx, **/*.ts
exclude: **/__tests__/**, **/*.test.*, **/*.spec.*, **/*.css
alwaysApply: false
---

# React Development Standards for Music Be Simple

## Component Architecture

### Single-Purpose Components

- **One component per file**: Each file contains exactly one React component
- **Bite-sized components**: Components should be focused and single-purpose (one thing == one component == one file)
- **Descriptive naming**: Use PascalCase with descriptive names indicating visual purpose
- **Component suffixes**: Use appropriate suffixes when needed (e.g., `Container`, `Panel`, `Button`, `Display`)

### Component Guidelines

- **TypeScript types**: Prefer `type` over `interface` for component props and data structures
- **Named exports only**: Export components as named exports using `export function ComponentName` (NO default exports)
- **Import paths**: 
  - Use relative imports (`./` or `../`) for siblings, direct children, or direct parents (NOT root level)
  - Use `@/` alias for all other imports (cross-directory, root level, etc.)
- **Import order**: All imports at top without blank lines for auto-sorting:
  1. Internal project imports with `@/` alias (alphabetically: components, context, hooks, instruments, navigation, schemas, stores, utils)
  2. Type imports from `@/types` and other `@/` paths (alphabetically)
  3. React value imports (from 'react')
  4. Third-party libraries (alphabetically: clsx, zod, etc.)
  5. Relative imports (alphabetically)
  6. Type imports from React (import type from 'react') - comes last
- **Separate code and type imports**: If importing both code and types from the same file, use separate import statements
- **Props interface**: Define clear, typed props with descriptive names
- **forwardRef usage**: Use `forwardRef` for components that need to expose DOM refs when needed
- **JSX attribute order**: The attributes `ref`, `key`, and `id` must be the last three attributes (in that order) when present. If only some of them are present, they should still be in that order and be last.
- **Memoized components**: Export memoized components at the bottom of the file as a named export

### Performance Optimization

#### React.memo Usage

- **Memoization criteria**: Apply `memo` to components with stable props or frequent re-renders when performance is a concern
- **Current status**: Not currently used extensively - apply only when needed for performance optimization
- **When to use**: Use for components that receive stable props and render frequently

#### Memoization Guidelines

```typescript
// âœ… Use memo when component has stable props and frequent re-renders
import { memo } from 'react';

type TopButtonProps = {
  title: string;
  icon: string;
  position: 'left' | 'right';
  onFxn: () => void;
};

function TopButtonComponent({ title, icon, position, onFxn }: TopButtonProps) {
  return (
    <button
      type='button'
      className={`...`}
      onClick={onFxn}
    >
      {icon}
    </button>
  );
}

export const TopButton = memo(TopButtonComponent);
```

**When to use React.memo:**

- **UI components with stable props**: Components that receive props that don't change often
- **Display components**: Components that render frequently but with the same data
- **Button components**: Buttons that receive stable props

**When NOT to use React.memo:**

- **Layout components**: Main, Navbar (these rarely re-render)
- **Components with frequently changing props**: Components that receive new props on every render
- **Simple components**: Components that are already fast enough
- **Page components**: Chords, Scales, Play (typically don't need memoization)

#### Performance Optimization Patterns

```typescript
// âœ… useCallback for event handlers
import { useCallback, useState } from 'react';

import { Main } from '@/components/Main';

export function Chords() {
  const [localState, setLocalState] = useState('');

  const handleAction = useCallback(() => {
    // Handle action
    setLocalState('updated');
  }, []);

  return (
    <Main componentName='Chords'>
      <button onClick={handleAction}>Action</button>
    </Main>
  );
}
```

```typescript
// âœ… useMemo for expensive computations
import { useMemo } from 'react';

function SectionComponent({ data }: SectionProps) {
  // Memoize expensive calculations
  const processedData = useMemo(() => {
    return data.map(item => expensiveCalculation(item));
  }, [data]);

  return <div>{/* render processed data */}</div>;
}
```

#### Lazy Loading and Code Splitting

```typescript
// âœ… Use lazy loading for page components in App.tsx
import { Suspense, lazy } from 'react';

const ChordsPage = lazy(() => import('@/pages/Chords').then((m) => ({ default: m.Chords })));
const ScalesPage = lazy(() => import('@/pages/Scales').then((m) => ({ default: m.Scales })));

// In App component
<Suspense fallback={<div>Loading...</div>}>
  <ActivePageComponent />
</Suspense>
```

### Performance Considerations

#### Memoization

- **React.memo**: Use for components with stable props when performance is a concern
- **useMemo**: Use for expensive computations (e.g., data processing, filtering)
- **useCallback**: Use for event handlers passed as props to memoized children

### Bundle Optimization

- **Tree shaking**: Import only necessary components and utilities
- **Dynamic imports**: Use for large components when appropriate
- **Code splitting**: Leverage Vite's automatic code splitting

## State Management

### Local State

- **useState**: Use for component-local state
- **State lifting**: Lift state up when multiple components need access
- **State organization**: Keep state as close to where it's used as possible

#### State Guidelines

```typescript
// âœ… Use useState for local component state
import { useState } from 'react';

function ComponentWithState() {
  const [isExpanded, setIsExpanded] = useState(false);

  const toggle = () => {
    setIsExpanded(!isExpanded);
  };

  return (
    <div>
      <button onClick={toggle}>Toggle</button>
      {isExpanded && <div>Content</div>}
    </div>
  );
}
```

### State Management

- **Hybrid approach**: Combines Zustand stores and React Context API
- **Zustand stores**: Manage tonic and variant state (in `src/stores/`) with sessionStorage persistence
- **React Context API**: Provides computed values, UI state, and additional functionality
- **Context providers**: Context providers located in `src/context/` directory
- **Custom hooks**: Use custom hooks (`useChords`, `useScales`, `usePlay`, `useGlobals`, `useInstrumentNotes`, `useTunings`) to access context values
- **Store hooks**: Use store hooks (`useChordsStore`, `useScalesStore`, `usePlayStore`) to access store state
- **Provider pattern**: `AppProviders` in `App.tsx` composes all providers and wraps the app (Navbar, pages, Footer)
- **Persistence**: 
  - **sessionStorage** (Zustand): Tonic and variant state (persists during navigation, clears on refresh)
  - **localStorage** (`useLocalStorage`): UI preferences (persists across refreshes)
- **Type safety**: All context values and store state are typed with TypeScript
- **Schema validation**: Zod schemas validate sessionStorage and localStorage data and user inputs at runtime

#### Zustand Stores

- **chordsStore**: Chords tonic and variant state (sessionStorage, clears on refresh)
- **scalesStore**: Scales tonic and variant state (sessionStorage, clears on refresh)
- **playStore**: Play functionality state (sessionStorage)

#### Context Providers

- **GlobalsContext**: Global application state (note display preferences, selected displays, using flats/sharps, audio context, note playback) - uses localStorage
- **ScalesContext**: Scales-specific state (uses scalesStore for tonic/variant, computed notes, showNoteLabels) - showNoteLabels in localStorage
- **ChordsContext**: Chords-specific state (uses chordsStore for tonic/variant, computed notes, chordName, noteCount, showNerdMode) - showNerdMode in localStorage
- **PlayContext**: Play functionality state
- **InstrumentNotesContext**: Instrument notes display (`InstrumentNotesProvider` in `Displays` when rendering instruments)
- **TuningsContext**: Custom instrument tunings, TuningModal (getTuning, setTuning, resetTuning, openTuningModal, closeTuningModal); persisted in localStorage

#### Schema Validation

All context providers and Zustand stores use Zod schemas for runtime validation:

- **sessionStorage validation**: Data loaded from sessionStorage (in Zustand stores) is validated using Zod schemas in custom storage implementations
- **localStorage validation**: Data loaded from localStorage is validated using Zod schemas (each field validated individually via `useLocalStorage` hook)
- **Combined data validation**: Context providers also validate combined storage data using storage schemas (`GlobalsStorageSchema`, `ScalesStorageSchema`, `ChordsStorageSchema`) in `useEffect` hooks for monitoring and debugging
- **Input validation**: User inputs are validated using `safeParse()` before state updates
- **Schema location**: All schemas are defined in `src/schemas.ts`
- **Error handling**: Validation errors are logged and fall back to default values gracefully
- **Persistence scope**: 
  - **sessionStorage** (Zustand): `tonic` and `variant` for scales and chords (persists during navigation, clears on refresh)
  - **localStorage**: `usingFlats`, `selectedDisplays`, `showNoteLabels`, `showNerdMode`, `instrumentTunings` (Tunings), `chordBinItems`, `notepadLines` (Play) (persists across refreshes)

```typescript
// âœ… Schema validation in context providers (localStorage - individual fields)
import { useLocalStorage } from '@/context/shared/useLocalStorage';
import { IconTypeSchema } from '@/schemas';
import { z } from 'zod';

const [displays, setDisplays] = useLocalStorage(
  'selectedDisplays',
  z.array(IconTypeSchema),
  initialDisplays
);

// âœ… Combined data validation in context providers (for monitoring/debugging)
import { GlobalsStorageSchema } from '@/schemas';

useEffect(() => {
  const combinedData = {
    usingFlats,
    selectedDisplays: displays,
  };
  const result = GlobalsStorageSchema.safeParse(combinedData);
  if (!result.success) {
    console.warn('Globals storage data validation failed:', result.error.format());
  }
}, [usingFlats, displays]);

// âœ… Schema validation in Zustand stores (sessionStorage)
import { NoteIndexSchema, ScaleTypeSchema } from '@/schemas';

const scalesStorage = {
  getItem: (name: string): string | null => {
    const item = sessionStorage.getItem(name);
    if (!item) return null;
    const parsed = JSON.parse(item);
    if (parsed.state) {
      const validatedTonic = NoteIndexSchema.safeParse(parsed.state.tonic);
      const validatedVariant = ScaleTypeSchema.safeParse(parsed.state.variant);
      if (validatedTonic.success && validatedVariant.success) {
        return item;
      }
      return null;
    }
    return null;
  },
  // ... setItem, removeItem
};
```

```typescript
// âœ… Input validation in components
import { NoteIndexSchema } from '@/schemas';

const handleChange = (e: ChangeEvent<HTMLSelectElement>) => {
  const value = Number.parseInt(e.target.value, 10);
  const result = NoteIndexSchema.safeParse(value);
  if (result.success && isValidNoteIndex(result.data)) {
    handleTonicChange(result.data);
  }
};
```

#### State Usage

```typescript
// âœ… Use context hooks (recommended - provides computed values)
import { Main } from '@/components/Main';
import { useScales } from '@/hooks/useScales';
import { useGlobals } from '@/hooks/useGlobals';

export function Scales() {
  const { tonic, variant, notes, handleTonicChange } = useScales();
  const { displays, usingFlats } = useGlobals();
  
  return (
    <Main componentName='Scales'>
      {/* Use state */}
    </Main>
  );
}

// âœ… Use store hooks directly (if you only need tonic/variant)
import { useScalesStore } from '@/stores/scalesStore';

export function MyComponent() {
  const { tonic, variant, setTonic, setVariant } = useScalesStore();
  
  return (
    <div>
      {/* Use store state */}
    </div>
  );
}
```

#### Context Provider Pattern

`App.tsx` uses `AppProviders`, which composes: Globals â†’ Tunings â†’ Scales â†’ Chords â†’ Play. `InstrumentNotesProvider` is used in `Displays` when rendering instruments.

```typescript
// App.tsx
import { AppProviders } from '@/context';

export function App() {
  return (
    <AppProviders>
      {/* Navbar, active page, Footer */}
    </AppProviders>
  );
}
```

## Accessibility Standards

### ARIA and Semantics

- **Proper ARIA labels**: Include appropriate ARIA labels and roles
- **Keyboard navigation**: Support keyboard navigation with proper tabIndex
- **Focus management**: Implement proper focus management
- **Screen reader compatibility**: Ensure screen reader compatibility
- **Color contrast**: Maintain proper color contrast ratios
- **Semantic HTML**: Use semantic HTML structure (header, main, footer, nav, etc.)

### Error Handling

- **Error message association**: Associate error messages with form fields when applicable
- **Loading state announcements**: Announce loading states to screen readers when needed
- **Error boundaries**: Implement error boundaries for graceful error handling when needed
- **Defensive programming**: Include validation and fallbacks for data integrity

## Music Be Simple-Specific Guidelines

### Page Components

All page components follow similar patterns:

- **Chords**: Chords page for chord-related functionality
- **Scales**: Scales page for scale-related functionality
- **Play**: Play page (instruments, Chord Bin, Notepad, Save/Import/Export, note playback)

### Page Component Pattern

- **Main wrapper**: All pages use the `Main` component wrapper
- **Component name**: Pass component name to Main for styling
- **State management**: Use React Context API with custom hooks for state
- **Top buttons**: Use TopButton component for page-specific actions

### Layout Components

- **Main**: Main content wrapper component with page-specific styling
- **Navbar**: Navigation bar with tabs for Scales, Chords, and Play
- **NavTab**: Individual navigation tab component using button with onFxn handler
- **Footer**: Footer component with copyright information
- **Title**: Title component for page headings

### Routing

- **Manual Routing**: Routing is implemented in `App.tsx` using React state and browser History API
- **URL synchronization**: URL is updated using `window.history.pushState` and `window.history.replaceState`
- **Browser navigation**: Handles browser back/forward navigation with `popstate` event listener
- **Navigation components**: Use button elements with handler functions (e.g., `onFxn`) for navigation

### Typography

- **Typographic apostrophe**: Use ' instead of ' in all user-facing text
- **CSS variables**: Typography uses CSS variables defined in globals.css
- **Tailwind classes**: Use Tailwind typography utilities for consistent styling

### Icons

- **Emoji icons**: Use emoji icons for simple visual indicators (e.g., 'ðŸ“–' for TopButton)
- **Icon accessibility**: Include appropriate title attributes for icon buttons
- **Icon sizing**: Icons are sized via className on button elements

### Styling

- **Tailwind CSS**: Use Tailwind utility classes for styling (v4 with Vite plugin)
- **Custom CSS**: Use custom CSS classes for page-specific styling (Chords, Scales, Play)
- **CSS variables**: Use CSS variables for colors defined in globals.css (--chords, --scales, --play)
- **Responsive design**: Use Tailwind responsive prefixes (sm:, md:, lg:, xl:)
- **clsx utility**: Use `clsx` for conditional class names when needed

## File Organization

### Component Structure

Abbreviated; see `.cursor/rules.mdc` and `documentation/COMPONENTS.md` for full structure.

```
src/components/
â”œâ”€â”€ buttons/ (TopButton, AddButton, CloseButton, TransposeButton, UseFlatsButton, ...)
â”œâ”€â”€ displays/ (Displays, DisplaySelector, modes/, instruments/)
â”œâ”€â”€ icons/, nav/
â”œâ”€â”€ Main, PageLayout, SkipLink, TuningModal, Title, Tonic, Variant, ...
```

### Page Structure

```
src/pages/
â”œâ”€â”€ Chords/ (Chords, Chord, ChordName, ChordNotes, Notes, ...)
â”œâ”€â”€ Play/ (Play, ChordBin, Notepad, SaveSection, InstrumentSelector, ...)
â””â”€â”€ Scales/ (Scales, Notes, Scale, ScaleContainer, ...)
```


### Store Structure

```
src/stores/ (chordsStore, scalesStore, playStore, index.ts)

src/context/
â”œâ”€â”€ AppProviders.tsx   # Composes Globals â†’ Tunings â†’ Scales â†’ Chords â†’ Play
â”œâ”€â”€ Chords/, Globals/, InstrumentNotes/, Play/, Scales/, Tunings/
â”œâ”€â”€ shared/ (useChordState, useEscapeReset, useLocalStorage, useRequireGlobals, useScaleState)
â””â”€â”€ index.ts

src/hooks/
â”œâ”€â”€ useButtonHandler, useChords, useDragDropClassName, useDraggableItem, useDropZone
â”œâ”€â”€ useGlobals, useInstrumentNotes, usePlay, usePlayNote, useScales, useTunings
â””â”€â”€ index.ts
```

### Entry Point

```
src/
â”œâ”€â”€ main.tsx              # Application entry point (StrictMode, App)
â”œâ”€â”€ App.tsx               # AppProviders, routing, lazy-loaded pages
â”œâ”€â”€ globals.css           # Global styles and CSS variables
â”œâ”€â”€ navigation.ts         # TABS, route helpers
â”œâ”€â”€ instruments.ts        # Instrument definitions
â”œâ”€â”€ schemas.ts            # Zod schemas
â””â”€â”€ vite-env.d.ts
```

## Development Workflow

### Scripts

- **`bun dev`**: Start development server with HMR
- **`bun run build`**: Build for production (TypeScript compilation + Vite build)
- **`bun lint`**: Run Biome linter
- **`bun format`**: Format code with Biome

### Code Quality

- **TypeScript**: Strict type checking enabled
- **Biome**: Code formatting, linting, and import organization (replaces ESLint + Prettier)
- **Import organization**: Use `@/` path alias for imports
- **Vite**: Build tool with React plugin and Tailwind CSS v4 integration

### Performance Patterns

- **Lazy loading**: Use `lazy()` and `Suspense` for code splitting page components if needed
- **React.memo**: Use for components with stable props when performance is a concern
- **useCallback**: Use for event handlers passed to memoized children
- **useMemo**: Use for memoizing context values and expensive computations
- **State management**: Use Zustand stores for tonic/variant state and React Context API with custom hooks for computed values and UI state

### Testing

The project uses a comprehensive testing setup with Vitest and Playwright:

- **Unit Tests**: Vitest + React Testing Library for utility functions and hooks
- **Component Tests**: Vitest + React Testing Library for React components
- **E2E Tests**: Playwright for end-to-end user flow testing
- **Coverage**: Vitest Coverage (v8) for code coverage reports

#### Test Structure

- Unit: `src/utils/__tests__/`, `src/hooks/__tests__/`
- Component: `src/components/__tests__/`
- E2E: `e2e/` (scales, chords, play, navigation), `e2e/fixtures/` (e.g. import-all.json)
- Other: `src/__tests__/` (e.g. schemas), `context/__tests__/`, `context/shared/__tests__/`, `stores/__tests__/`, `components/displays/instruments/__tests__/`
- Test utilities: `src/test/test-utils.tsx`, `src/test/setup.ts`

#### Testing Best Practices

- **Test behavior, not implementation**: Focus on what users see and do
- **Use semantic queries**: Prefer `getByRole`, `getByLabelText` over `getByTestId`
- **Keep tests isolated**: Each test should be independent
- **Write descriptive test names**: Use clear descriptions of what is being tested
- **Test user interactions**: Use `@testing-library/user-event` for interactions
- **Mock external dependencies**: Mock APIs, localStorage, etc.
- **Keep E2E tests focused**: Test critical user flows, not every detail

#### Test Utilities

- Use `render` from `@/test/test-utils` for components that need context providers
- Test setup includes mocks for `matchMedia`, `IntersectionObserver`, and `AudioContext`
- Coverage reports are generated in the `coverage/` directory

#### Running Tests

```bash
# Run unit and component tests once (CI mode) (Vitest)
bun run test

# Run tests in watch mode (development)
bun run test:watch

# Run tests with UI
bun run test:ui

# Run tests with coverage
bun run test:coverage

# Run E2E tests
bun run test:e2e

# Run all tests
bun run test:all
```

**Note**: Use `bun run test` (not `bun test`) to run Vitest. Bun's built-in test runner is not supported due to compatibility issues with Testing Library.
