---
globs: **/*.tsx, **/*.ts
exclude: **/__tests__/**, **/*.test.*, **/*.spec.*, **/routes/**, **/*.css
alwaysApply: false
---

# React Development Standards for Music Be Simple

## Component Architecture

### Single-Purpose Components

- **One component per file**: Each file contains exactly one React component
- **Bite-sized components**: Components should be focused and single-purpose (one thing == one component == one file)
- **Descriptive naming**: Use PascalCase with descriptive names indicating visual purpose
- **Component suffixes**: Use appropriate suffixes when needed (e.g., `Container`, `Panel`, `Button`, `Display`)

### Component Guidelines

- **TypeScript types**: Prefer `type` over `interface` for component props and data structures
- **Default exports**: Export components as default exports using `export default function ComponentName`
- **Import paths**: Use `@/` path alias for imports (configured in tsconfig.json)
- **Import order**: Type imports come before value imports (e.g., `import type { ReactNode } from 'react'` before `import { useState } from 'react'`)
- **Props interface**: Define clear, typed props with descriptive names
- **forwardRef usage**: Use `forwardRef` for components that need to expose DOM refs when needed
- **JSX attribute order**: The `key` attribute must be the last attribute in any JSX element

### Performance Optimization

#### React.memo Usage

- **Memoization criteria**: Apply `memo` to components with stable props or frequent re-renders when performance is a concern
- **Current status**: Not currently used extensively - apply only when needed for performance optimization
- **When to use**: Use for components that receive stable props and render frequently

#### Memoization Guidelines

```typescript
// âœ… Use memo when component has stable props and frequent re-renders
import { memo } from 'react';

type TopButtonProps = {
  title: string;
  icon: string;
  position: 'left' | 'right';
  onFxn: () => void;
};

function TopButton({ title, icon, position, onFxn }: TopButtonProps) {
  return (
    <button
      type='button'
      className={`...`}
      onClick={onFxn}
    >
      {icon}
    </button>
  );
}

export default memo(TopButton);
```

**When to use React.memo:**

- **UI components with stable props**: Components that receive props that don't change often
- **Display components**: Components that render frequently but with the same data
- **Button components**: Buttons that receive stable props

**When NOT to use React.memo:**

- **Layout components**: Main, Navbar (these rarely re-render)
- **Components with frequently changing props**: Components that receive new props on every render
- **Simple components**: Components that are already fast enough
- **Page components**: Chords, Scales, Play (typically don't need memoization)

#### Performance Optimization Patterns

```typescript
// âœ… useCallback for event handlers
import { useCallback, useState } from 'react';

import Main from '@/components/Main';

export default function Chords() {
  const [localState, setLocalState] = useState('');

  const handleAction = useCallback(() => {
    // Handle action
    setLocalState('updated');
  }, []);

  return (
    <Main componentName='Chords'>
      <button onClick={handleAction}>Action</button>
    </Main>
  );
}
```

```typescript
// âœ… useMemo for expensive computations
import { useMemo } from 'react';

function SectionComponent({ data }: SectionProps) {
  // Memoize expensive calculations
  const processedData = useMemo(() => {
    return data.map(item => expensiveCalculation(item));
  }, [data]);

  return <div>{/* render processed data */}</div>;
}
```

#### Lazy Loading and Code Splitting

```typescript
// âœ… Use lazy loading for page components if needed
import { Suspense, lazy } from 'react';

const Chords = lazy(() => import('@/pages/Chords'));

function LoadingPage() {
  return (
    <div className='flex justify-center items-center h-screen'>
      <div className='text-lg'>Loading...</div>
    </div>
  );
}

export default function ChordsRoute() {
  return (
    <Suspense fallback={<LoadingPage />}>
      <Chords />
    </Suspense>
  );
}
```

### Performance Considerations

#### Memoization

- **React.memo**: Use for components with stable props when performance is a concern
- **useMemo**: Use for expensive computations (e.g., data processing, filtering)
- **useCallback**: Use for event handlers passed as props to memoized children

### Bundle Optimization

- **Tree shaking**: Import only necessary components and utilities
- **Dynamic imports**: Use for large components when appropriate
- **Code splitting**: Leverage Vite's automatic code splitting

## State Management

### Local State

- **useState**: Use for component-local state
- **State lifting**: Lift state up when multiple components need access
- **State organization**: Keep state as close to where it's used as possible

#### State Guidelines

```typescript
// âœ… Use useState for local component state
import { useState } from 'react';

function ComponentWithState() {
  const [isExpanded, setIsExpanded] = useState(false);

  const toggle = () => {
    setIsExpanded(!isExpanded);
  };

  return (
    <div>
      <button onClick={toggle}>Toggle</button>
      {isExpanded && <div>Content</div>}
    </div>
  );
}
```

### State Management

- **Hybrid approach**: Combines Zustand stores and React Context API
- **Zustand stores**: Manage tonic and variant state (in `src/stores/`) with sessionStorage persistence
- **React Context API**: Provides computed values, UI state, and additional functionality
- **Context providers**: Context providers located in `src/context/` directory
- **Custom hooks**: Use custom hooks (`useChords`, `useScales`, `usePlay`, `useGlobals`, `useInstrumentNotes`) to access context values
- **Store hooks**: Use store hooks (`useChordsStore`, `useScalesStore`, `usePlayStore`) to access store state
- **Provider pattern**: Context providers wrap page components at the route level
- **Persistence**: 
  - **sessionStorage** (Zustand): Tonic and variant state (persists during navigation, clears on refresh)
  - **localStorage** (`useLocalStorage`): UI preferences (persists across refreshes)
- **Type safety**: All context values and store state are typed with TypeScript
- **Schema validation**: Zod schemas validate sessionStorage and localStorage data and user inputs at runtime

#### Zustand Stores

- **chordsStore**: Chords tonic and variant state (sessionStorage, clears on refresh)
- **scalesStore**: Scales tonic and variant state (sessionStorage, clears on refresh)
- **playStore**: Play functionality state (sessionStorage)

#### Context Providers

- **GlobalsContext**: Global application state (note display preferences, selected displays, using flats/sharps, audio context, note playback) - uses localStorage
- **ScalesContext**: Scales-specific state (uses scalesStore for tonic/variant, computed notes, showNoteLabels) - showNoteLabels in localStorage
- **ChordsContext**: Chords-specific state (uses chordsStore for tonic/variant, computed notes, chordName, noteCount, showNerdMode) - showNerdMode in localStorage
- **PlayContext**: Play functionality state
- **InstrumentNotesContext**: Instrument notes display context (provides notes, tonic, and styling to instrument components)

#### Schema Validation

All context providers and Zustand stores use Zod schemas for runtime validation:

- **sessionStorage validation**: Data loaded from sessionStorage (in Zustand stores) is validated using Zod schemas in custom storage implementations
- **localStorage validation**: Data loaded from localStorage is validated using Zod schemas (each field validated individually via `useLocalStorage` hook)
- **Combined data validation**: Context providers also validate combined storage data using storage schemas (`GlobalsStorageSchema`, `ScalesStorageSchema`, `ChordsStorageSchema`) in `useEffect` hooks for monitoring and debugging
- **Input validation**: User inputs are validated using `safeParse()` before state updates
- **Schema location**: All schemas are defined in `src/schemas.ts`
- **Error handling**: Validation errors are logged and fall back to default values gracefully
- **Persistence scope**: 
  - **sessionStorage** (Zustand): `tonic` and `variant` for scales and chords (persists during navigation, clears on refresh)
  - **localStorage**: `usingFlats`, `selectedDisplays`, `showNoteLabels`, `showNerdMode` (persists across refreshes)

```typescript
// âœ… Schema validation in context providers (localStorage - individual fields)
import { useLocalStorage } from '@/context/shared/useLocalStorage';
import { IconTypeSchema } from '@/schemas';
import { z } from 'zod';

const [displays, setDisplays] = useLocalStorage(
  'selectedDisplays',
  z.array(IconTypeSchema),
  initialDisplays
);

// âœ… Combined data validation in context providers (for monitoring/debugging)
import { GlobalsStorageSchema } from '@/schemas';

useEffect(() => {
  const combinedData = {
    usingFlats,
    selectedDisplays: displays,
  };
  const result = GlobalsStorageSchema.safeParse(combinedData);
  if (!result.success) {
    console.warn('Globals storage data validation failed:', result.error.format());
  }
}, [usingFlats, displays]);

// âœ… Schema validation in Zustand stores (sessionStorage)
import { NoteIndexSchema, ScaleTypeSchema } from '@/schemas';

const scalesStorage = {
  getItem: (name: string): string | null => {
    const item = sessionStorage.getItem(name);
    if (!item) return null;
    const parsed = JSON.parse(item);
    if (parsed.state) {
      const validatedTonic = NoteIndexSchema.safeParse(parsed.state.tonic);
      const validatedVariant = ScaleTypeSchema.safeParse(parsed.state.variant);
      if (validatedTonic.success && validatedVariant.success) {
        return item;
      }
      return null;
    }
    return null;
  },
  // ... setItem, removeItem
};
```

```typescript
// âœ… Input validation in components
import { NoteIndexSchema } from '@/schemas';

const handleChange = (e: ChangeEvent<HTMLSelectElement>) => {
  const value = Number.parseInt(e.target.value, 10);
  const result = NoteIndexSchema.safeParse(value);
  if (result.success && isValidNoteIndex(result.data)) {
    handleTonicChange(result.data);
  }
};
```

#### State Usage

```typescript
// âœ… Use context hooks (recommended - provides computed values)
import Main from '@/components/Main';
import { useScales } from '@/hooks/useScales';
import { useGlobals } from '@/hooks/useGlobals';

export default function Scales() {
  const { tonic, variant, notes, handleTonicChange } = useScales();
  const { displays, usingFlats } = useGlobals();
  
  return (
    <Main componentName='Scales'>
      {/* Use state */}
    </Main>
  );
}

// âœ… Use store hooks directly (if you only need tonic/variant)
import { useScalesStore } from '@/stores/scalesStore';

export default function MyComponent() {
  const { tonic, variant, setTonic, setVariant } = useScalesStore();
  
  return (
    <div>
      {/* Use store state */}
    </div>
  );
}
```

#### Context Provider Pattern

```typescript
// âœ… Route file wraps page with context provider
import { ScalesContextProvider } from '@/context';
import Scales from '@/pages/Scales';
import { createFileRoute } from '@tanstack/react-router';

function ScalesPage() {
  return (
    <ScalesContextProvider>
      <Scales />
    </ScalesContextProvider>
  );
}

export const Route = createFileRoute('/scales')({
  component: ScalesPage,
});
```

## Accessibility Standards

### ARIA and Semantics

- **Proper ARIA labels**: Include appropriate ARIA labels and roles
- **Keyboard navigation**: Support keyboard navigation with proper tabIndex
- **Focus management**: Implement proper focus management
- **Screen reader compatibility**: Ensure screen reader compatibility
- **Color contrast**: Maintain proper color contrast ratios
- **Semantic HTML**: Use semantic HTML structure (header, main, footer, nav, etc.)

### Error Handling

- **Error message association**: Associate error messages with form fields when applicable
- **Loading state announcements**: Announce loading states to screen readers when needed
- **Error boundaries**: Implement error boundaries for graceful error handling when needed
- **Defensive programming**: Include validation and fallbacks for data integrity

## Music Be Simple-Specific Guidelines

### Page Components

All page components follow similar patterns:

- **Chords**: Chords page for chord-related functionality
- **Scales**: Scales page for scale-related functionality
- **Play**: Play page for music playback functionality

### Page Component Pattern

- **Main wrapper**: All pages use the `Main` component wrapper
- **Component name**: Pass component name to Main for styling
- **State management**: Use React Context API with custom hooks for state
- **Top buttons**: Use TopButton component for page-specific actions

### Layout Components

- **Main**: Main content wrapper component with page-specific styling
- **Navbar**: Navigation bar with tabs for Scales, Chords, and Play
- **NavTab**: Individual navigation tab component using TanStack Router Link
- **Footer**: Footer component with copyright information
- **Title**: Title component for page headings

### Routing

- **TanStack Router**: File-based routing in `src/routes/` directory
- **Route structure**: Each route file exports a route definition
- **Root route**: `__root.tsx` defines layout with Navbar and Outlet
- **Navigation**: Use Link component from TanStack Router for navigation

### Typography

- **Typographic apostrophe**: Use ' instead of ' in all user-facing text
- **CSS variables**: Typography uses CSS variables defined in globals.css
- **Tailwind classes**: Use Tailwind typography utilities for consistent styling

### Icons

- **Emoji icons**: Use emoji icons for simple visual indicators (e.g., 'ðŸ“–' for TopButton)
- **Icon accessibility**: Include appropriate title attributes for icon buttons
- **Icon sizing**: Icons are sized via className on button elements

### Styling

- **Tailwind CSS**: Use Tailwind utility classes for styling (v4 with Vite plugin)
- **Custom CSS**: Use custom CSS classes for page-specific styling (Chords, Scales, Play)
- **CSS variables**: Use CSS variables for colors defined in globals.css (--chords, --scales, --play)
- **Responsive design**: Use Tailwind responsive prefixes (sm:, md:, lg:, xl:)
- **clsx utility**: Use `clsx` for conditional class names when needed

## File Organization

### Component Structure

```
src/components/
â”œâ”€â”€ Main.tsx              # Main content wrapper component
â”œâ”€â”€ Navbar.tsx            # Navigation bar component
â”œâ”€â”€ NavTab.tsx            # Navigation tab component
â””â”€â”€ TopButton.tsx         # Top button component
```

### Page Structure

```
src/pages/
â”œâ”€â”€ Chords/
â”‚   â””â”€â”€ index.tsx         # Chords page component
â”œâ”€â”€ Scales/
â”‚   â””â”€â”€ index.tsx         # Scales page component
â””â”€â”€ Play/
    â””â”€â”€ index.tsx          # Play page component
```

### Route Structure

```
src/routes/
â”œâ”€â”€ __root.tsx            # Root route layout
â”œâ”€â”€ index.tsx             # Home/index route
â”œâ”€â”€ chords.tsx            # Chords route
â”œâ”€â”€ play.tsx              # Play route
â””â”€â”€ scales.tsx            # Scales route
```

### Store Structure

```
src/stores/
â”œâ”€â”€ chordsStore.ts
â”œâ”€â”€ scalesStore.ts
â”œâ”€â”€ playStore.ts
â””â”€â”€ index.ts

src/context/
â”œâ”€â”€ Chords/
â”œâ”€â”€ Globals/
â”œâ”€â”€ Play/
â”œâ”€â”€ Scales/
â”œâ”€â”€ shared/
â””â”€â”€ index.ts

src/hooks/
â”œâ”€â”€ useButtonHandler.ts
â”œâ”€â”€ useChords.ts
â”œâ”€â”€ useGlobals.ts
â”œâ”€â”€ useInstrumentNotes.ts
â”œâ”€â”€ usePlay.ts
â”œâ”€â”€ usePlayNote.ts
â””â”€â”€ useScales.ts
```

### Entry Point

```
src/
â”œâ”€â”€ main.tsx              # Application entry point
â”œâ”€â”€ globals.css           # Global styles and CSS variables
â”œâ”€â”€ navigation.ts         # Navigation constants and schemas
â”œâ”€â”€ instruments.ts        # Instrument definitions
â””â”€â”€ vite-env.d.ts         # Vite environment type definitions
```

## Development Workflow

### Scripts

- **`bun dev`**: Start development server with HMR
- **`bun run build`**: Build for production (TypeScript compilation + Vite build)
- **`bun lint`**: Run Biome linter
- **`bun format`**: Format code with Biome

### Code Quality

- **TypeScript**: Strict type checking enabled
- **Biome**: Code formatting, linting, and import organization (replaces ESLint + Prettier)
- **Import organization**: Use `@/` path alias for imports
- **Vite**: Build tool with React plugin, TanStack Router plugin, and Tailwind CSS v4 integration

### Performance Patterns

- **Lazy loading**: Use `lazy()` and `Suspense` for code splitting page components if needed
- **React.memo**: Use for components with stable props when performance is a concern
- **useCallback**: Use for event handlers passed to memoized children
- **useMemo**: Use for memoizing context values and expensive computations
- **State management**: Use Zustand stores for tonic/variant state and React Context API with custom hooks for computed values and UI state

### Testing

The project uses a comprehensive testing setup with Vitest and Playwright:

- **Unit Tests**: Vitest + React Testing Library for utility functions and hooks
- **Component Tests**: Vitest + React Testing Library for React components
- **E2E Tests**: Playwright for end-to-end user flow testing
- **Coverage**: Vitest Coverage (v8) for code coverage reports

#### Test Structure

- Unit tests: `src/utils/__tests__/`, `src/hooks/__tests__/`
- Component tests: `src/components/__tests__/`
- E2E tests: `e2e/`
- Test utilities: `src/test/test-utils.tsx` (custom render with router context)
- Test setup: `src/test/setup.ts` (mocks and global configuration)

#### Testing Best Practices

- **Test behavior, not implementation**: Focus on what users see and do
- **Use semantic queries**: Prefer `getByRole`, `getByLabelText` over `getByTestId`
- **Keep tests isolated**: Each test should be independent
- **Write descriptive test names**: Use clear descriptions of what is being tested
- **Test user interactions**: Use `@testing-library/user-event` for interactions
- **Mock external dependencies**: Mock APIs, localStorage, etc.
- **Keep E2E tests focused**: Test critical user flows, not every detail

#### Test Utilities

- Use `render` from `@/test/test-utils` for components that need router context
- Test setup includes mocks for `matchMedia`, `IntersectionObserver`, and `AudioContext`
- Coverage reports are generated in the `coverage/` directory

#### Running Tests

```bash
# Run unit and component tests in watch mode
bun test

# Run tests with UI
bun test:ui

# Run tests once (CI mode)
bun test:run

# Run tests with coverage
bun test:coverage

# Run E2E tests
bun test:e2e

# Run all tests
bun test:all
```
